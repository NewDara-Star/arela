# CLAUDE-005: Per-Slice Observability Setup

## Context
From Research Paper 1, we learned that **per-slice observability** is critical for debugging and monitoring VSA applications. Each slice should automatically tag all logs, metrics, and traces with the slice/feature name.

This enables:
- ‚úÖ Filter logs by feature in Datadog/New Relic
- ‚úÖ See performance metrics per slice
- ‚úÖ Trace requests through multiple slices
- ‚úÖ Debug issues faster (know which slice failed)

## Problem
Currently, there's no automatic tagging of observability data by slice. Developers must manually add tags, which is:
- ‚ùå Error-prone (easy to forget)
- ‚ùå Inconsistent (different naming)
- ‚ùå Time-consuming (boilerplate)

## Solution
Implement `arela setup observability` command that:
1. Detects slices in the codebase
2. Generates middleware to auto-tag requests by slice
3. Configures structured logging (JSON)
4. Sets up OpenTelemetry tracing
5. Adds correlation IDs

## Command Structure
```bash
# Setup observability
arela setup observability

# Specify provider
arela setup observability --provider datadog
arela setup observability --provider newrelic
arela setup observability --provider generic

# Specify framework
arela setup observability --framework express
arela setup observability --framework fastify
arela setup observability --framework gin
```

## Implementation

### 1. Observability Generator
```typescript
// src/setup/observability-generator.ts

import { detectSlices } from '../detect';
import { writeFile } from 'fs/promises';
import path from 'path';

export interface ObservabilityOptions {
  provider?: 'datadog' | 'newrelic' | 'generic';
  framework?: 'express' | 'fastify' | 'gin';
  enableTracing?: boolean;
  enableMetrics?: boolean;
}

export async function setupObservability(
  repoPath: string,
  options: ObservabilityOptions = {}
): Promise<void> {
  const {
    provider = 'generic',
    framework = 'express',
    enableTracing = true,
    enableMetrics = true,
  } = options;
  
  // 1. Detect slices
  const sliceReport = await detectSlices([repoPath]);
  
  // 2. Generate middleware
  const middlewareCode = generateMiddleware(sliceReport, framework);
  
  // 3. Generate logger config
  const loggerCode = generateLogger(provider);
  
  // 4. Generate tracer config (if enabled)
  let tracerCode = '';
  if (enableTracing) {
    tracerCode = generateTracer(provider);
  }
  
  // 5. Write files
  const outputDir = path.join(repoPath, 'src/observability');
  await writeFile(path.join(outputDir, 'middleware.ts'), middlewareCode);
  await writeFile(path.join(outputDir, 'logger.ts'), loggerCode);
  
  if (enableTracing) {
    await writeFile(path.join(outputDir, 'tracer.ts'), tracerCode);
  }
  
  console.log('‚úÖ Observability setup complete!');
  console.log(`   - Middleware: ${outputDir}/middleware.ts`);
  console.log(`   - Logger: ${outputDir}/logger.ts`);
  if (enableTracing) {
    console.log(`   - Tracer: ${outputDir}/tracer.ts`);
  }
}

function generateMiddleware(sliceReport, framework: string): string {
  if (framework === 'express') {
    return `
// Auto-generated by: arela setup observability
import { Request, Response, NextFunction } from 'express';
import { logger } from './logger';
import { v4 as uuidv4 } from 'uuid';

// Map routes to slices
const routeToSlice: Record<string, string> = {
${sliceReport.slices.map(slice => 
  `  '/api/v1/${slice.name}': '${slice.name}',`
).join('\n')}
};

export function observabilityMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
) {
  // Generate correlation ID
  const correlationId = req.headers['x-correlation-id'] as string || uuidv4();
  
  // Detect slice from path
  const slice = detectSliceFromPath(req.path);
  
  // Set context for this request
  logger.setContext({
    correlationId,
    slice,
    feature: slice,
    method: req.method,
    path: req.path,
    userId: req.user?.id,
  });
  
  // Add correlation ID to response headers
  res.setHeader('X-Correlation-ID', correlationId);
  
  // Log request
  logger.info('Request received', {
    method: req.method,
    path: req.path,
    slice,
  });
  
  // Track response time
  const startTime = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    
    logger.info('Request completed', {
      method: req.method,
      path: req.path,
      slice,
      statusCode: res.statusCode,
      duration,
    });
  });
  
  next();
}

function detectSliceFromPath(path: string): string | null {
  for (const [route, slice] of Object.entries(routeToSlice)) {
    if (path.startsWith(route)) {
      return slice;
    }
  }
  return null;
}
`;
  }
  
  // Add support for other frameworks (Fastify, Gin, etc.)
  throw new Error(\`Framework \${framework} not yet supported\`);
}

function generateLogger(provider: string): string {
  return `
// Auto-generated by: arela setup observability
import pino from 'pino';

// Structured JSON logger
export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  formatters: {
    level: (label) => {
      return { level: label };
    },
  },
  timestamp: pino.stdTimeFunctions.isoTime,
  
  // Add default fields
  base: {
    service: process.env.SERVICE_NAME || 'api',
    environment: process.env.NODE_ENV || 'development',
  },
});

// Context storage for request-scoped data
let context: Record<string, any> = {};

export const loggerWithContext = {
  setContext(ctx: Record<string, any>) {
    context = { ...context, ...ctx };
  },
  
  clearContext() {
    context = {};
  },
  
  info(message: string, data?: Record<string, any>) {
    logger.info({ ...context, ...data }, message);
  },
  
  error(message: string, error?: Error, data?: Record<string, any>) {
    logger.error({ ...context, ...data, error }, message);
  },
  
  warn(message: string, data?: Record<string, any>) {
    logger.warn({ ...context, ...data }, message);
  },
  
  debug(message: string, data?: Record<string, any>) {
    logger.debug({ ...context, ...data }, message);
  },
};

export { loggerWithContext as logger };
`;
}

function generateTracer(provider: string): string {
  return `
// Auto-generated by: arela setup observability
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: process.env.SERVICE_NAME || 'api',
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.SERVICE_VERSION || '1.0.0',
  }),
  instrumentations: [
    getNodeAutoInstrumentations({
      '@opentelemetry/instrumentation-fs': {
        enabled: false, // Disable filesystem instrumentation (noisy)
      },
    }),
  ],
});

sdk.start();

// Graceful shutdown
process.on('SIGTERM', () => {
  sdk.shutdown()
    .then(() => console.log('Tracing terminated'))
    .catch((error) => console.error('Error terminating tracing', error))
    .finally(() => process.exit(0));
});

export { sdk };
`;
}
```

### 2. CLI Command
```typescript
// src/cli.ts

program
  .command('setup observability')
  .description('Setup per-slice observability (logging, tracing, metrics)')
  .option('--provider <name>', 'Observability provider (datadog, newrelic, generic)', 'generic')
  .option('--framework <name>', 'Web framework (express, fastify, gin)', 'express')
  .option('--no-tracing', 'Disable distributed tracing')
  .option('--no-metrics', 'Disable metrics collection')
  .action(async (options) => {
    console.log('üìä Setting up observability...\n');
    
    try {
      await setupObservability(process.cwd(), options);
      
      console.log('\n‚úÖ Observability setup complete!');
      console.log('\nNext steps:');
      console.log('1. Install dependencies: npm install pino uuid @opentelemetry/sdk-node');
      console.log('2. Import middleware in your app: import { observabilityMiddleware } from "./observability/middleware"');
      console.log('3. Use middleware: app.use(observabilityMiddleware)');
      console.log('4. Use logger: import { logger } from "./observability/logger"');
      console.log('5. Set environment variables: SERVICE_NAME, LOG_LEVEL\n');
    } catch (error) {
      console.error('Error setting up observability:', error);
      process.exit(1);
    }
  });
```

### 3. Example Usage
```typescript
// src/main.ts
import express from 'express';
import { observabilityMiddleware } from './observability/middleware';
import { logger } from './observability/logger';

const app = express();

// Add observability middleware (FIRST!)
app.use(observabilityMiddleware);

// Your routes
app.get('/api/v1/workout/sessions', (req, res) => {
  logger.info('Fetching workout sessions');
  // ... handler logic
});

app.listen(3000, () => {
  logger.info('Server started', { port: 3000 });
});
```

### 4. Log Output
```json
{
  "level": "info",
  "time": "2025-11-13T23:00:00.000Z",
  "service": "api",
  "environment": "production",
  "correlationId": "abc-123-def-456",
  "slice": "workout",
  "feature": "workout",
  "method": "GET",
  "path": "/api/v1/workout/sessions",
  "userId": "user-789",
  "message": "Request received"
}
```

## Acceptance Criteria
- [ ] `arela setup observability` command implemented
- [ ] Generates middleware for auto-tagging by slice
- [ ] Structured JSON logging configured
- [ ] OpenTelemetry tracing setup (optional)
- [ ] Correlation IDs added automatically
- [ ] Works with Express (Fastify, Gin later)
- [ ] Provider-specific configs (Datadog, New Relic)
- [ ] Documentation added
- [ ] Example integration provided

## Testing
```bash
# Setup observability
cd /Users/Star/zombie-survival-game/backend
arela setup observability --framework express

# Install dependencies
npm install pino uuid @opentelemetry/sdk-node @opentelemetry/auto-instrumentations-node

# Integrate in app
# (manually add middleware to main.ts)

# Test
npm run dev
curl http://localhost:3000/api/v1/workout/sessions

# Check logs (should show slice tagging)
```

## Files to Create
- `src/setup/observability-generator.ts`
- `src/setup/templates/middleware.ts.template`
- `src/setup/templates/logger.ts.template`
- `src/setup/templates/tracer.ts.template`
- `test/setup/observability-generator.test.ts`
- `docs/observability.md`

## Priority
**P1 - HIGH**

Critical for production debugging and monitoring. Without this, it's hard to trace issues to specific slices.

## Dependencies
- CASCADE-003 (Louvain fix) - Needs accurate slice detection

## References
- Research Paper 1: Software Development Approaches Comparison
- OpenTelemetry docs: https://opentelemetry.io/
- Pino logger: https://getpino.io/

## Notes
- Middleware must be added FIRST (before routes)
- Correlation IDs enable tracing across services
- Structured JSON logs are required for modern observability platforms
- Per-slice tagging aligns monitoring with architecture

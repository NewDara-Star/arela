# CODEX-005: Architecture Tests Generator

## Context
From Research Paper 1, we learned that **programmatic guards** are essential to enforce VSA boundaries and prevent the AI (or developers) from violating architectural rules.

Architecture tests automatically fail the build if:
- ‚ùå A slice imports from another slice (boundary violation)
- ‚ùå A slice accesses another slice's database tables
- ‚ùå Shared code grows beyond acceptable limits

## Problem
Currently, there's no automated enforcement of slice boundaries. Developers (or AI agents) can accidentally:
- Import from other slices
- Create tight coupling
- Violate VSA principles

This leads to the same problems as horizontal layering.

## Solution
Implement `arela setup guards` command that generates architecture tests based on detected slices.

## Command Structure
```bash
# Generate architecture tests
arela setup guards

# Strict mode (stricter rules)
arela setup guards --strict

# Specify test framework
arela setup guards --framework vitest

# Custom output directory
arela setup guards --output tests/architecture
```

## Implementation

### 1. Test Generator
```typescript
// src/setup/guards-generator.ts

import { detectSlices } from '../detect';
import { writeFile } from 'fs/promises';
import path from 'path';

export interface GuardsOptions {
  strict?: boolean;
  framework?: 'vitest' | 'jest' | 'mocha';
  output?: string;
}

export async function generateArchitectureTests(
  repoPath: string,
  options: GuardsOptions = {}
): Promise<void> {
  // 1. Detect slices
  const sliceReport = await detectSlices([repoPath]);
  
  // 2. Generate test file
  const testCode = generateTestCode(sliceReport, options);
  
  // 3. Write to file
  const outputPath = options.output || path.join(repoPath, 'tests/architecture');
  await writeFile(
    path.join(outputPath, 'slice-boundaries.test.ts'),
    testCode
  );
  
  console.log(`‚úÖ Architecture tests generated: ${outputPath}/slice-boundaries.test.ts`);
}

function generateTestCode(sliceReport, options): string {
  const { framework = 'vitest', strict = false } = options;
  
  return `
// Auto-generated by: arela setup guards
// DO NOT EDIT - Regenerate with: arela setup guards

import { describe, it, expect } from '${framework}';
import { checkSliceBoundaries, checkSharedImports } from '@arela/architecture';

describe('Slice Boundaries', () => {
  it('should not allow cross-slice imports', async () => {
    const violations = await checkSliceBoundaries({
      slices: ${JSON.stringify(sliceReport.slices.map(s => s.name))},
      strict: ${strict}
    });
    
    expect(violations).toEqual([]);
    
    // If this fails, you have cross-slice imports:
    // - Slice A importing from Slice B
    // - Fix: Move shared code to shared/ or use events/contracts
  });
  
  it('should only import from shared kernel', async () => {
    const violations = await checkSharedImports({
      allowedShared: ['shared/utils', 'shared/types', 'shared/config']
    });
    
    expect(violations).toEqual([]);
    
    // If this fails, you're importing from non-shared code
  });
  
  ${strict ? `
  it('should have minimal shared code', async () => {
    const sharedSize = await getSharedCodeSize();
    const totalSize = await getTotalCodeSize();
    const ratio = sharedSize / totalSize;
    
    expect(ratio).toBeLessThan(0.1); // Shared code < 10%
    
    // If this fails, you have too much shared code
    // - Refactor shared code into slices
    // - Or accept higher ratio with --no-strict
  });
  ` : ''}
  
  it('should have isolated database access', async () => {
    const violations = await checkDatabaseAccess();
    
    expect(violations).toEqual([]);
    
    // If this fails, slices are accessing each other's tables
    // - Each slice should own its tables
    // - Use events or APIs for cross-slice data access
  });
});

describe('Slice Cohesion', () => {
  ${sliceReport.slices.map(slice => `
  it('${slice.name} should have high cohesion', async () => {
    const cohesion = await calculateCohesion('${slice.name}');
    
    expect(cohesion).toBeGreaterThan(0.7); // 70% cohesion
    
    // If this fails, files in this slice are not related
    // - Consider splitting into multiple slices
    // - Or merging with another slice
  });
  `).join('\n')}
});
`;
}
```

### 2. Boundary Checker
```typescript
// src/architecture/boundary-checker.ts

import { loadGraph } from '../detect/graph-loader';
import path from 'path';

export interface BoundaryViolation {
  from: string;
  to: string;
  type: 'cross-slice-import' | 'database-access' | 'shared-violation';
  message: string;
}

export async function checkSliceBoundaries(options: {
  slices: string[];
  strict: boolean;
}): Promise<BoundaryViolation[]> {
  const graph = loadGraph('.arela/memory/graph.db');
  const violations: BoundaryViolation[] = [];
  
  // Check each edge
  for (const edge of graph.edges) {
    const fromNode = graph.nodes.find(n => n.id === edge.from);
    const toNode = graph.nodes.find(n => n.id === edge.to);
    
    if (!fromNode || !toNode) continue;
    
    const fromSlice = getSliceFromPath(fromNode.path, options.slices);
    const toSlice = getSliceFromPath(toNode.path, options.slices);
    
    // Cross-slice import detected
    if (fromSlice && toSlice && fromSlice !== toSlice) {
      violations.push({
        from: fromNode.path,
        to: toNode.path,
        type: 'cross-slice-import',
        message: `Slice "${fromSlice}" imports from slice "${toSlice}"`,
      });
    }
  }
  
  return violations;
}

export async function checkSharedImports(options: {
  allowedShared: string[];
}): Promise<BoundaryViolation[]> {
  const graph = loadGraph('.arela/memory/graph.db');
  const violations: BoundaryViolation[] = [];
  
  for (const edge of graph.edges) {
    const toNode = graph.nodes.find(n => n.id === edge.to);
    if (!toNode) continue;
    
    // Check if importing from shared/
    if (toNode.path.startsWith('shared/')) {
      const isAllowed = options.allowedShared.some(allowed =>
        toNode.path.startsWith(allowed)
      );
      
      if (!isAllowed) {
        violations.push({
          from: graph.nodes.find(n => n.id === edge.from)!.path,
          to: toNode.path,
          type: 'shared-violation',
          message: `Importing from non-allowed shared code: ${toNode.path}`,
        });
      }
    }
  }
  
  return violations;
}

function getSliceFromPath(filePath: string, slices: string[]): string | null {
  for (const slice of slices) {
    if (filePath.includes(`features/${slice}/`)) {
      return slice;
    }
  }
  return null;
}
```

### 3. CLI Command
```typescript
// src/cli.ts

program
  .command('setup guards')
  .description('Generate architecture tests to enforce slice boundaries')
  .option('--strict', 'Enable strict mode (stricter rules)')
  .option('--framework <name>', 'Test framework (vitest, jest, mocha)', 'vitest')
  .option('--output <path>', 'Output directory', 'tests/architecture')
  .action(async (options) => {
    console.log('üõ°Ô∏è  Generating architecture tests...\n');
    
    try {
      await generateArchitectureTests(process.cwd(), options);
      
      console.log('\n‚úÖ Architecture tests generated!');
      console.log('\nNext steps:');
      console.log('1. Run tests: npm run test:architecture');
      console.log('2. Add to CI: See .github/workflows/architecture.yml');
      console.log('3. Fix violations if any\n');
    } catch (error) {
      console.error('Error generating tests:', error);
      process.exit(1);
    }
  });
```

### 4. CI Template
```yaml
# .github/workflows/architecture.yml (auto-generated)
name: Architecture Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18
      
      - name: Install dependencies
        run: npm install
      
      - name: Run architecture tests
        run: npm run test:architecture
        
      # Fail build if boundaries violated
```

## Acceptance Criteria
- [ ] `arela setup guards` command implemented
- [ ] Generates architecture tests based on detected slices
- [ ] Tests check for cross-slice imports
- [ ] Tests check for shared code violations
- [ ] Tests check for database access isolation
- [ ] Strict mode available
- [ ] CI template generated
- [ ] Documentation added
- [ ] Works with vitest, jest, mocha

## Testing
```bash
# Generate tests
cd /Users/Star/zombie-survival-game/backend
arela setup guards

# Run generated tests
npm run test:architecture

# Expected output:
# ‚úÖ Slice Boundaries
#    ‚úÖ should not allow cross-slice imports
#    ‚úÖ should only import from shared kernel
#    ‚úÖ should have isolated database access
```

## Files to Create
- `src/setup/guards-generator.ts`
- `src/architecture/boundary-checker.ts`
- `src/architecture/cohesion-calculator.ts`
- `test/setup/guards-generator.test.ts`
- `docs/architecture-tests.md`

## Priority
**P1 - HIGH**

Critical for preventing AI hallucination and developer mistakes. Without this, VSA boundaries can be violated.

## Dependencies
- CASCADE-003 (Louvain fix) - Needs accurate slice detection

## Notes
- These tests run in CI automatically
- Fail build if boundaries violated
- Prevent both AI and human mistakes
- Essential for maintaining VSA over time
